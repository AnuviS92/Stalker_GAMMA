
--[[

	Tronex
	2021/3/1
	Dialog UI

	Features:
		- dialog system remade in LUA, full user access
		- support for passing custom function parameters in XML dialog files (Ex: dialog_manager.init_new_dialog(true,meme,4) )
			(params can be boolean/number/string, they will be converted to their proper types automatically on lua side)
			Note: nil parameter will be passed as false for technical reasons
		- no crash on missing nodes, you get a warning message in log
		- validate functionality that will automatically tells you if there are missing nodes
		- ability to reload dialog and character tables on the fly, your recent changes in xml files will be taken into account upon reloading
			use the debug_key to reload the tables, "enable_debug_key" must be set to true
		- New dialog property: <run_once> for dialogs that should be said once and never repeated again.
			This makes it easier than using the old method of info portion to do the job
			<run_once/> will mark dialog as completed once it reach the last phrase automatically
			<run_once>3</run_once> will mark dialog as completed once it passes phrase with id "3", you can set it at any phrase of your choice
		- ability to show relocated items as icons instead of lengthy texts, like in inventory
		- ability to inject dialogs to an NPC with specific ID
		
	See how XML dialog is converted to a table inside "dialog_list" down below, which can help you modifying parsed dialogs directly from scripts
--]]

local enable_feature = true
local enable_debug = false
local enable_debug_key = false
local enable_debug_clear_log = true
local debug_key = DIK_keys.DIK_HOME

local max_partner_distance = 2.5 --[meters]
local default_start_dialog = "hello_dialog"
local default_actor_dialog = "actor_break_dialog"
local special_characters = {
	["m_trader"] = "esc_2_12_stalker_trader",
	["m_lesnik"] = "red_forester_tech",
	["zat_a2_stalker_nimble"] = "esc_2_12_stalker_nimble",
}

local engine_start_dialog = {} -- has highest priority for start dialogs, controlled by meet logic
character_id_list         = {} -- list of start/actor dialogs to an NPC with specific id, can be set to override (character_list)
character_list            = {} -- list of start/actor dialogs to a character (character_desc xml files)
dialog_list               = {} -- dialogs table (dialog xml files)
dialog_finished           = {} -- dialogs included here won't be repeated, loaded/saved by m_data

local talk_captured = false

local table_insert = table.insert
local string_find = string.find
local string_gsub = string.gsub
local pairs = pairs
local ipairs = ipairs
local tostring = tostring

local function parse_custom_func(str, no_brackets)
	-- Convert string: "{=file.func(param1:param2:param3:...)}" --> {file, func, param1, param2, param3, ...}
	
	if (type(str) ~= "string") then
		callstack()
	end
	
	-- Extract script, function, parameters list
	local _,__,sf,s,f,p
	if (not no_brackets) then
		_,__,str = string_find(str,"%((.*)%)")
	end
	
	if string_find(str,"%((.*)%)") then
		_,__,sf,p = string_find(str,"(.*)%((.*)%)")
		
		if string_find(str,"%.") then
			_,__,s,f = string_find(sf,"(.*)%.(.*)")
		else
			f = sf
		end
	else
		sf = str
		if string_find(str,"%.") then
			_,__,s,f = string_find(sf,"(.*)%.(.*)")
		else
			f = sf
		end
	end

	if not (f and f ~= "") then
		printe("ERROR parse_custom_func: %s | func name is wrong", str)
		return {}
	end
	
	-- Extract parameters one by one
	if p and p ~= "" then
		p = string_gsub(p,"\"","") -- remove quotes
		p = string_gsub(p,"'","") -- remove quotes
		p = str_explode(p,",")	
		
		for i=1,#p do
			if string_find(p[i],"%(") or string_find(p[i],"%)") then printe("ERROR parse_custom_func: %s | func name is wrong: %s", p[i]) end
			
			if (p[i] == "true") then
				p[i] = true
			elseif (p[i] == "false") or (p[i] == "nil") then
				p[i] = false
			elseif tonumber(p[i]) then
				p[i] = tonumber(p[i])
			end
		end
	end

	local t = { s , f }
	if p and (type(p) == "table") then
		for i=1,#p do
			t[#t+1] = p[i]
		end
	end
	
	return t
end

local function on_key_release(key)
	if db.actor and db.actor:alive() then
		local bind = dik_to_bind(key)
		if (bind == key_bindings.kUSE) then
			local npc = level.get_target_obj() or nil
			if npc then
				if IsStalker(npc) or special_characters[npc:section()] then
					if npc:alive() and (npc:id() == talk_captured) and (distance_between(npc, db.actor) <= max_partner_distance) then
						npc:enable_talk()
						talk_captured = false
						start(npc)
					end
				end
			end
			
		elseif enable_debug_key and key == debug_key then
			if GUI and GUI:IsShown() then
				GUI:Close()
			end
			
			prepare_dialog_table()
			prepare_character_table()
			
			printf("------------------------------------------------")
			printf("- UIDialog: Reloaded dialog and character tables")
			printf("------------------------------------------------")
		end
	end
end

local function on_key_press(key)
	if db.actor and db.actor:alive() then
		local bind = dik_to_bind(key)
		if (bind == key_bindings.kUSE) then
			local npc = level.get_target_obj() or nil
			if npc then
				if IsStalker(npc) or special_characters[npc:section()] then
					if npc:alive() and npc:is_talk_enabled() then
						npc:disable_talk()
						talk_captured = npc:id()
					end
				end
			end
		end
	end
end

local function load_state(m_data)
	dialog_finished = m_data.dialog_finished or {}
end

local function save_state(m_data)
	m_data.dialog_finished = dialog_finished
end


function on_game_start()
	if enable_feature then
		RegisterScriptCallback("on_key_release",on_key_release)
		RegisterScriptCallback("on_key_press",on_key_press)
		RegisterScriptCallback("save_state",save_state)
		RegisterScriptCallback("load_state",load_state)

		prepare_dialog_table()
		prepare_character_table()
		overrides_2()
	end
end

----------------------------------------------------------------------
-- instances, don't touch
GUI = nil 
local dialog_script = nil

function start(npc, distant, name, icon)
	if (not npc) then
		printf("!ERROR dialog | no game object passed!")
		return
	end
	
	local hud = get_hud()
	if (hud) then
		hide_hud_inventory()
	end
	
	if enable_debug then
		printf("dialog -> starting chat with [%s]", npc:name())
	end
	
	if (not GUI) then
		GUI = UIDialog()
	end
	
	if (GUI) and (not GUI:IsShown()) then
		GUI:Reset(npc, distant, name, icon)
		GUI:ShowDialog(true)
		
		Register_UI("Dialog",script_name())

		-- Needed for now to simulate engine functionality in calling this, called after GUI showing
		actor_menu.actor_menu_mode(10)
		pda.actor_menu_mode(10)				 
	end
end

----------------------------------------------------------------------
-- Support
----------------------------------------------------------------------
-- Inject a dialog table into dialogs list
function add_dialog(name, dl)
-- add new dialog to the dialogs table
	dialog_list[name] = dl
end
function add_script_dialog(p_id,id,phrase_id,cond,act)
-- to use by other scripts for scripted dialog (init_func)

	if (not dialog_script) then
		dialog_script = DialogScripted()
	end

	local phrase = dialog_script:AddPhrase(phrase_id,tostring(id),tostring(p_id),-10000)
	if not ( phrase ) then
		return
	end

	local phrase_script = phrase:GetPhraseScript()
	if ( cond ) then
		if ( type(cond) == "table" ) then
			for key, value in pairs(cond) do
				phrase_script:AddPrecondition(value)
			end
		else
			phrase_script:AddPrecondition(cond)
		end
	end

	if ( act ) then
		if ( type(act) == "table" ) then
			for key, value in pairs(act) do
				phrase_script:AddAction(value)
			end
		else
			phrase_script:AddAction(act)
		end
	end
	
	if (phrase_id and string.find(phrase_id,"%.")) then
		phrase_script:SetScriptText(phrase_id)
	end
	
	return phrase_script
end

-- Add/Remove/Check dialog for a character (by name)
function char_add_dialog(name, dialog, typ, order)
	-- this function adds new dialog to a character
-- name: character section as it's defined in character_desc (don't add default_* as it's seen in files, Ex: use sim_default_csky_1 instead of sim_default_csky_1_default_3)
-- dialog: name of dialog you want to add to the character
-- typ: [boolean] true: start_dialog | false: actor_dialog
-- order: [number] order of the added dialog inside dialog list for the character (Ex: typ (false) order (3) means that it will be the 3rd actor_dialog available by said character)

	if (not character_list[name]) then character_list[name] = {} end
	
	if typ then
		if (not character_list[name].start_dialog) then character_list[name].start_dialog = {} end
		local c = #character_list[name].start_dialog
		if order and c > order then
			table_insert( character_list[name].start_dialog , order, {dialog} )
		else
			table_insert( character_list[name].start_dialog , {dialog} )
		end
	else
		if (not character_list[name].actor_dialog) then character_list[name].actor_dialog = {} end
		local c = #character_list[name].actor_dialog
		if order and c > order then
			table_insert( character_list[name].actor_dialog , order, {dialog} )
		else
			table_insert( character_list[name].actor_dialog , {dialog} )
		end
	end
end
function char_remove_dialog(name, dialog, typ)
	-- this function removes dialog from a character
-- name: character section as it's defined in character_desc (don't add default_* as it's seen in files, Ex: use sim_default_csky_1 instead of sim_default_csky_1_default_3)
-- dialog: name of dialog you want to remove from character dialogs
-- typ: [boolean] true: start_dialog | false: actor_dialog

	local dls
	if typ then
		dls = character_list[name] and character_list[name].start_dialog
	else
		dls = character_list[name] and character_list[name].actor_dialog
	end
	
	if (not dls) then
		return
	end
	
	for i,d in ipairs(dls) do
		for j,n in ipairs(d) do
			if (n == dialog) then
				d[j] = nil
				if #d == 0 then
					dls[i] = nil
				end
			end
		end
	end
end
function char_has_dialog(name, dialog, typ)
	-- this function returns true if a dialog exists for a character
-- name: character section as it's defined in character_desc (don't add default_* as it's seen in files, Ex: use sim_default_csky_1 instead of sim_default_csky_1_default_3)
-- dialog: name of dialog you want to remove from character dialogs
-- typ: [boolean] true: start_dialog | false: actor_dialog

	local dls
	if typ then
		dls = character_list[name] and character_list[name].start_dialog
	else
		dls = character_list[name] and character_list[name].actor_dialog
	end
	
	if (not dls) then
		return false
	end
	
	for i,d in ipairs(dls) do
		for j,n in ipairs(d) do
			if (n == dialog) then
				return true
			end
		end
	end
	return false
end

-- Add/Remove/Check dialog for an object (by ID)
function npc_add_dialogs(id, start_dialogs, start_override, actor_dialogs, actor_override)
-- use this function to inject a list of start/actor dialogs to an NPC with specific ID
-- Example: dialog_manager.npc_add_dialogs(3024, {"hello","start_1"}, true, {"dialog_breaker"}, false)

	-- id: character's id
	-- start_dialogs table contains start dialogs to insert
	-- actor_dialogs table contains actor dialogs to insert
	-- start_override: (true) to override default start dialogs, (false) to add them to the rest of start dialogs the NPC originally has
	-- actor_override: (true) to override default actor dialogs, (false) to add them to the rest of actor dialogs the NPC originally has
	
	-- NOTE: without using npc_remove_dialogs function first, dialogs previously injected to npc will stack on the new ones
	-- NOTE: without using override params, dialogs added this way will appear "before" any dialogs the NPC originally has
	
	if start_dialogs then
		for i,dialog in ipairs(start_dialogs) do
			npc_add_dialog(id, dialog, true)
		end
		npc_override_dialog(id, true, start_override)
	end
	
	if actor_dialogs then
		for i,dialog in ipairs(actor_dialogs) do
			npc_add_dialog(id, dialog, false)
		end
		npc_override_dialog(id, false, actor_override)
	end
end
function npc_add_dialog(id, dialog, typ)
	-- this function adds new dialog to a character with specific ID
-- id: character's id
-- dialog: name of dialog you want to add to the character
-- typ: [boolean] true: start_dialog | false: actor_dialog

	if (not character_id_list[id]) then character_id_list[id] = {} end
	
	if typ then
		if (not character_id_list[id].start_dialog) then character_id_list[id].start_dialog = {} end
		table_insert( character_id_list[id].start_dialog , {dialog} )
	else
		if (not character_id_list[id].actor_dialog) then character_id_list[id].actor_dialog = {} end
		table_insert( character_id_list[id].actor_dialog , {dialog} )
	end
end
function npc_remove_dialog(id, dialog, typ)
	-- this function removes dialog from a character
-- id: character's id
-- dialog: name of dialog you want to remove from character dialogs
-- typ: [boolean] true: start_dialog | false: actor_dialog

	local dls
	if typ then
		dls = character_id_list[id] and character_id_list[id].start_dialog
	else
		dls = character_id_list[id] and character_id_list[id].actor_dialog
	end
	
	if (not dls) then
		return
	end
	
	for i,d in ipairs(dls) do
		for j,n in ipairs(d) do
			if (n == dialog) then
				d[j] = nil
				if #d == 0 then
					dls[i] = nil
				end
			end
		end
	end
end
function npc_remove_dialogs(id)
	-- to remove added dialog list to character by specific id
	character_id_list[id] = nil
end
function npc_has_dialog(id, dialog, typ)
	-- this function returns true if a dialog exists for a character with specific id
-- id: character's id
-- dialog: name of dialog you want to know if character has
-- typ: [boolean] true: start_dialog | false: actor_dialog

	local dls
	if typ then
		dls = character_id_list[id] and character_id_list[id].start_dialog
	else
		dls = character_id_list[id] and character_id_list[id].actor_dialog
	end
	
	if (not dls) then
		return false
	end
	
	for i,d in ipairs(dls) do
		for j,n in ipairs(d) do
			if (n == dialog) then
				return true
			end
		end
	end
	return false
end
function npc_override_dialog(id, typ, state)
	-- use this function to mark dialogs added to specific character id in order to:
	--	1. completely override old dialog and only show the added ones
	--	2. include them with the rest of normal dialogs
-- id: character's id
-- state: [boolean] true: override | false: inclusion
-- typ: [boolean] true: start_dialog | false: actor_dialog

	if (not character_id_list[id]) then character_id_list[id] = {} end
	if state then
		if typ then
			character_id_list[id].override_start_dialog = true
		else
			character_id_list[id].override_actor_dialog = true
		end
	else
		if typ then
			character_id_list[id].override_start_dialog = nil
		else
			character_id_list[id].override_actor_dialog = nil
		end
	end
end

-- Show other things on dialog UI, like info box or items list
function show_info(caption, context, icon, element, delay, sound)
	if not (GUI and GUI:IsShown()) then
		return false
	end
	
	table.insert(GUI.info_queue , { element=element , caption=caption , context=context , icon=icon , moment= (time_global() + (delay or 0)) , sound=sound })
	return true
end
function show_relocated_item(typ, item, amount)
-- To show item icon on dialog by relocate item functions. No dialog means show them as news
-- Dialog UI waits half a second to show the items, so when relocating happens in sequence, all of them will show up in the same in/out list

	if db.actor == nil then return false end
	if not (item and ini_sys:section_exist(item)) then 
		printe("!ERROR: relocate_item - section %s does not exist",item)
		return false
	end
	
	-- Talking -> Showcase
	if GUI and GUI:IsShown() then
		amount = amount or 1
		if (typ == "in") then
			local c = #GUI.item_listing.inv_in + 1
			for i=c,c+(amount-1) do
				GUI.item_listing.inv_in[i] = item
				GUI.item_listing.trigger = time_global()
			end
		else
			local c = #GUI.item_listing.inv_out + 1
			for i=c,c+(amount-1) do
				GUI.item_listing.inv_out[i] = item
				GUI.item_listing.trigger = time_global()
			end
		end
		
	-- Not talking -> News
	else
		amount = amount or 1
		local news_text = item and ui_item.get_sec_name(item) or ""
		local news_caption = (typ == "in") and "general_in_item" or "general_out_item"
		local news_ico = (typ == "in") and "ui_inGame2_Predmet_poluchen" or "ui_inGame2_Predmet_otdan"
		if (amount > 1) then
			news_text = news_text .. " x" .. amount
		end
		
		db.actor:give_game_news( game.translate_string(news_caption), news_text, news_ico, 0, 3000)
	end
end
function show_relocated_item_list(typ, item_list)
-- To show item list icons on dialog. item_list is a table that contains item sections
	if not (db.actor and item_list) then
		return
	end
	
	-- Talking -> Showcase
	if not (GUI and GUI:IsShown()) then
		return false
	end
	
	-- Talking -> Showcase
	if (typ == "in") then
		GUI.item_listing.inv_in = item_list
	else
		GUI.item_listing.inv_out = item_list
	end
	GUI.item_listing.trigger = time_global()
end


----------------------------------------------------------------------
-- UI
----------------------------------------------------------------------
class "UIDialog" (CUIScriptWnd)

function UIDialog:__init() super()
	self.ID            = false
	self.sec           = false
	self.name          = false
	self.icon          = false
	self.dialogs       = {}
	self.character     = {}
	self.start_dialogs = {}

	self.face_to_face  = true
	self.is_npc        = false
	self.offline       = false
	self.pos           = false
	
	self.D             = false
	self.N             = false
	self.Q             = {}
	self.Q_all		   = {}
	self.QW            = false

	self.tg_npc        = 0
	self.tg_npc_rate   = 1000
	self.tg_up         = 0
	self.tg_up_rate    = 1000
	
	self.item_boxes    = {}
	self.item_listing  = { delay= 500 , trigger= false, inv_in= {} , inv_out= {} }
	self.info_queue    = {}

	self:InitControls()
end

function UIDialog:__finalize()
end

function UIDialog:InitControls()
	self:SetWndRect			(Frect():set(0,0,1024,768))
	self:SetAutoDelete(true)
	
	self.xml				= CScriptXmlInit()
	local xml = self.xml
	xml:ParseFile			("talk.xml")

	self.dialog					= xml:InitStatic("main", self)
	self.answers_list 			= xml:InitScrollView("answers_list", self.dialog)
	self.questions_list 		= xml:InitScrollView("questions_list", self.dialog)
	self.item_info 				= utils_ui.UIInfoItem(self, 1000)
	
	self.ele_q = {}
end

function UIDialog:Reset(npc, distant, name, icon)
	self:Print("$", "", "Reset for: %s", npc:name())
	
	if enable_debug and enable_debug_clear_log then
		get_console():execute("clear_log")
	end

	-- main data
	empty_table(self.character)
	empty_table(self.dialogs)
	empty_table(self.info_queue)

	self.offline = (type(npc.id) == "number")
	self.is_npc = IsStalker(npc)
	self.face_to_face = (not self.offline) and (distant ~= true) and true or false
	
	self.ID = self.offline and npc.id or npc:id()
	self.sec = self.offline and npc:section_name() or npc:section()
	self.name = name or false
	self.icon = icon or false
	
	-- special case for Sid
	if special_characters[self.sec] then
		self.sec = special_characters[self.sec]
		self.is_npc = true
	end
	
	-- look at NPC
	if self.face_to_face and self.is_npc then
		self.pos = npc:bone_position("bip01_head")
		db.actor:actor_look_at_point(self.pos)
	end
	
	self.answers_list:Clear()
	self.questions_list:Clear()
	for i,b in ipairs(self.item_boxes) do
		b.active = false
	end
	
	-- Preparing character dialogs
	local dls = character_list[self.sec]
	local dls_id = character_id_list[self.ID]
	
	-- start dialogs
	if dls_id and dls_id.start_dialog then
		self.character.start_dialog = dup_table(dls_id.start_dialog)
	else
		self.character.start_dialog = {}
	end
	if dls and dls.start_dialog and (not (dls_id and dls_id.override_start_dialog)) then
		for i,d in ipairs(dls.start_dialog) do
			table_insert( self.character.start_dialog , d )
		end
	end
	if is_empty(self.character.start_dialog) then
		self.character.start_dialog = default_start_dialog and {{ default_start_dialog }}
	end
	
	-- dialog dialogs
	if dls_id and dls_id.actor_dialog then
		self.character.actor_dialog = dup_table(dls_id.actor_dialog)
	else
		self.character.actor_dialog = {}
	end
	if dls and dls.actor_dialog and (not (dls_id and dls_id.override_actor_dialog)) then
		for i,d in ipairs(dls.actor_dialog) do
			table_insert( self.character.actor_dialog , d )
		end
	end
	if is_empty(self.character.actor_dialog) then
		self.character.actor_dialog = default_actor_dialog and {{ default_actor_dialog }}
	end
	
	-- management data
	self.queue = false
	self.D = false
	self.N = false
	self.Q = {}
	
	-- can't continue without character dialogs
	if (not self.character) then
		self:Close()
	end
	
	self:Move_Start()
end

function UIDialog:Update()
	CUIScriptWnd.Update(self)
	
	-- Queue Conversation
	if self.queue then
		local valid = type(self.queue) == "table"
		self:Print("$", "", "Shift queue to phrase")
		
		local dialog    = valid and self.queue[1]
		local node_last = valid and self.queue[2]
		local node_now  = valid and self.queue[3]
		local who       = valid and self.queue[4]
		self.queue = nil
		if valid then
			self:Move_Phrase(dialog, node_last, node_now, who)
		end
		
	elseif (self.queue == false) then
		self:Print("$", "", "Shift queue to main", valid)
		self.queue = nil
		self:Move_Main()
	end
	

---------------------------------
	local tg = time_global()
---------------------------------
	
	-- Capture item list to show on dialog
	if self.item_listing.trigger and (tg - self.item_listing.trigger > self.item_listing.delay) then
		self.item_listing.trigger = false
		
		if is_not_empty(self.item_listing.inv_out) then
			self:Show_Relocated_Items("out", self.item_listing.inv_out)
			empty_table(self.item_listing.inv_out)
		end
		if is_not_empty(self.item_listing.inv_in) then
			self:Show_Relocated_Items("in", self.item_listing.inv_in)
			empty_table(self.item_listing.inv_in)
		end
	end
	
	-- Send info from queue
	for i,info in ipairs(self.info_queue) do
		if (tg >= info.moment) then
			self:Show_Answer(info.caption, info.context, info.icon, info.element, info.sound)
			table.remove(self.info_queue, i)
		end
	end
	
	-- Updating item info box
	local found_cell = false
	for i,b in ipairs(self.item_boxes) do
		if b.active then
			found_cell = found_cell or b.CC:Update(self.item_info)
		end
	end
	if (not found_cell) then
		self.item_info:Update()
	end
	
---------------------------------	
	-- Updating NPC
	if (tg > self.tg_npc) then
		self.tg_npc = tg + self.tg_npc_rate
		
	---------------------------------
		-- Close dialog if NPC doesn't exist
		local npc = self:Get_NPC()
		if (not npc) then
			self:Close()
			return
		end
		
		-- Keep looking at NPC, move cam if NPC moved
		if self.face_to_face and self.is_npc then
			local pos = npc:bone_position("bip01_head")
			if (self.pos:distance_to(pos) > 0.5) then
				self.pos = pos
				db.actor:actor_look_at_point(self.pos)
			end
		end
		
		-- Close dialog if NPC is dead
		if self.is_npc and (not npc:alive()) then
			self:Close()
			return
		end
		
		-- Close dialog if NPC is far
		if self.face_to_face and (distance_between(npc, db.actor) > max_partner_distance) then
			self:Close()
			return
		end
	end
	
---------------------------------
	-- Update Dialogs
	if (tg > self.tg_up) then
		self.tg_up = tg + self.tg_up_rate

		-- Update main dialog list if a precondition result is changed
		if self.QW then
			local need_refresh = false
			for i,t in ipairs(self.Q_all) do
				local precond_now = self:Process_Preconditions(t.dialog)
				if precond_now ~= t.precond then
					need_refresh = true
				end
			end
			
			if need_refresh then
				self:Move_Main()
			end
			
		-- Update dialog phrases list if a precondition result is changed
		else
			local need_refresh = false
			local sample
			for i,t in ipairs(self.Q_all) do
				local precond_now = self:Process_Preconditions(t.dialog, t.node_now, t.node_new, t.who_next)
				if precond_now ~= t.precond then
					need_refresh = true
				end
				if (not sample) then
					sample = t
				end
			end
			
			if need_refresh and sample then
				self:Move_Phrase(sample.dialog, sample.node_last, sample.node_now, sample.who)
			end
		end
	end
end

-- Management
function UIDialog:Move_Start()
	self:Print("$", "", "Move_Start")
	
	-- begin with start_dialog
	local st = engine_start_dialog[self.ID]
	local dls = (st and {{ st }}) or self.character.start_dialog
	
	if dls then
		for i,p in ipairs(dls) do
		
			-- pick random dialog from the same order group
			local dialog = p[ random_key_table(p) ]
			
			-- if preconditions are met, initiate this dialog
			if self:Process_Preconditions(dialog) then
				self:Move_Phrase(dialog, false, "0", false)
				return
			end
		end
	end
	
	-- In case all start dialogs failed, use the default
	self:Move_Phrase(default_start_dialog, false, "0", false)
end

function UIDialog:Move_Main()
	self:Print("$", "", "Move_Main")
	
	-- resetting
	self.N = false
	self.D = false
	for dialog, dl in pairs(self.dialogs) do
		if dl.functor then
			dl.phrases = nil -- to generate new dynamic dialog on going to main body
		end
	end
	
	-- gather dialogs
	empty_table(self.Q_all)
	local dialog_valid = {}
	
	local dls = self.character.actor_dialog
	if dls then
		for i,p in ipairs(dls) do
			-- pick random dialog from the same order group
			local dialog = p[ random_key_table(p) ]
			
			-- Collect dialog if preconditions are met
			local precond = false
			if self:Process_Preconditions(dialog) then
				--printf("inserted dialog: %s", dialog)
				table_insert(dialog_valid, dialog)
				precond = true
			end
			
			local t = {}
			t.precond = precond
			t.dialog = dialog
			table_insert(self.Q_all, t)
		end
	end
	if is_empty(dialog_valid) then
		dialog_valid = { default_actor_dialog }
		self.Q_all = { { dialog = default_actor_dialog , precond = true , index = 1 } }
	end
	
	-- show questions
	self.questions_list:Clear()
	
	for i,dialog in ipairs(dialog_valid) do
		local text = self:Get_Text(dialog, false, "0", true)
		if text then
			self:Show_Question( game.translate_string(text), i)
		end
	end
	
	self.QW = true
	self.Q = dialog_valid
end

function UIDialog:Move_Phrase(dialog, node_last, node_now, who)
	-- this function will be called to move to next phrase
	-- return false -> failed to move -> break to main dialog
	-- return true -> successfully moved -> return current node
	local data = str_data(dialog, node_last, node_now, who)
	
	if (not dialog) then
		dialog = self.D
	end
	self.D = dialog
	
	if (node_last == nil) then
		node_last = self.N
	end
	self:Print("$", data, "Move_Phrase [%s] -> [%s]", node_last, node_now)
	
	-- Get dialog tree and current phrase
	local dlp = self:Get_Dialog(dialog, node_now)
	if (not dlp) then
		self:Print("=", data, "Move_Phrase | node [%s] not found", node_now)
		self.queue = false
		return
	end
	
	-- We need to push text when it's the first node of start dialog by NPC
	if (not who) and (node_now == "0") then
		local text = self:Get_Text(dialog, node_last, node_now, who)
		if text then
			self:Show_Answer(self:Get_NPC_Name(), game.translate_string(text), self:Get_NPC_Icon(), "other_answer_item")
			self:Print("=", data, "Answer by NPC on node [%s]", node_now)
		end
	end
	
	-- Do actions of current node if they exist
	self:Process_Actions(dialog, node_now, node_now, who)
	
----------- NEXT STAGE
	local who_next = not who
	
	-- Mark dialogs with "run once" prop on this node as finished, to never run them again
	local run_once = self:Get_Dialog_Property(dialog, "run_once")
	if (node_now == run_once) then
		dialog_finished[dialog] = true
	end
	
	-- get next nodes
	local node_next = dlp.next
	if (not node_next) then
		self:Print("=", data, "No next nodes found -> return false")
		self.queue = false
		
		-- Mark dialogs with unspecified "run once" prop as finished once dialog is over, to never run them again
		if (run_once == true) then
			dialog_finished[dialog] = true
		end
		return
	end
	
	-- get next valid nodes
	empty_table(self.Q_all)
	local node_valid = {}
	for i,node_new in ipairs(node_next) do
		
		local precond = false
		if self:Process_Preconditions(dialog, node_now, node_new, who_next) then
			table_insert(node_valid, node_new)
			precond = true
		end
		
		local t = {}
		t.precond = precond
		t.dialog = dialog
		t.node_last = node_last
		t.node_now = node_now
		t.node_new = node_new
		t.who = who
		t.who_next = who_next
		
		table_insert(self.Q_all, t)
	end
	self:Print("=", data, "Next nodes gathered: %s", str_nodes(node_valid))
	
	
	-- actor turn to speak -> ask questions
	if who_next then
		self:Print("=", data, "Speaker: Actor")
		
		self.questions_list:Clear()
		
		-- Post questions
		local text_found = false
		for i,node_new in ipairs(node_valid) do
			local text = self:Get_Text(dialog, node_now, node_new, who_next)
			if text then
				text_found = true
				self:Show_Question( game.translate_string(text), i)
			end
		end
		
		-- Questions are valid -> preserve them for callback
		if text_found then
			self:Print("=", data, "Successfully moved, questions posted")
			self.QW = false
			self.Q = node_valid
			self.N = node_now
			
			self.queue = true
			return
			
		-- No text was there -> randomize
		else
			local node_rand = node_valid[math.random(#node_valid)]
			self:Print("=", data, "No text found -> move to random node [%s]", node_rand)
			
			self.queue = { dialog, node_now, node_rand, who_next}
			return
		end
		
	-- npc turn to speak -> answer
	else
		self:Print("=", data, "Speaker: NPC")
		
		for i,node_new in ipairs(node_valid) do
			local text = self:Get_Text(dialog, node_now, node_new, who_next)
			if text then
				self:Show_Answer(self:Get_NPC_Name(), game.translate_string(text), self:Get_NPC_Icon(), "other_answer_item")
				
				self:Print("=", data, "Answer by NPC on node [%s]", node_new)
				self.queue = {dialog, node_now, node_new, who_next}
				return
			end
		end
		
		-- No text was there -> randomize
		local node_rand = node_valid[math.random(#node_valid)]
		self:Print("=", data, "No text found -> move to random node [%s]", node_rand)
		
		self.queue = {dialog, node_now, node_rand, who_next}
		return
	end
end

function UIDialog:Ask_Selected_Question(index)
	local value = self.Q[index]
	if (not value) then
		self:Print("-", "", "Ask_Selected_Question | index (%s) has no assigned question", index)
		return
	end
	self:Print("-", "", "_____________Ask_Selected_Question | index: %s - value: %s - type: %s", index, value, type(value))
		
	-- In case it's a selected dialog
	if (self.QW == true) then
		local text = self:Get_Text(value, false, "0", true)
		self:Show_Answer( game.translate_string("st_actor_generic_name"), game.translate_string(text), db.actor:character_icon(), "actor_answer_item")
		
		local node = self:Move_Phrase(value, false, "0", true)
		if (not node) then
			--self:Move_Main()
		end
		
	-- In case it's a selected phrase
	elseif (self.QW == false) then
		local text = self:Get_Text(self.D, self.N, value, true)
		self:Show_Answer( game.translate_string("st_actor_generic_name"), game.translate_string(text), db.actor:character_icon(), "actor_answer_item")
		
		local node = self:Move_Phrase(self.D, self.N, value, true)
		if (not node) then
			--self:Move_Main()
		end
	end
end

function UIDialog:Process_Preconditions(dialog, node_last, node_now, who)
	local data = str_data(dialog, node_last, node_now, who)
	--self:Print("=", data,"Preconditions")
	
	local dl = self:Get_Dialog(dialog, node_now)
	local conds = dl.precondition or dl.conds -- could be dialog or phrase preconditions
	if conds then
		for i,p in ipairs(conds) do
			local key = random_key_table(p)
			local value = p[key]

			if (key == "has_info") and (not has_alife_info(value)) then
				self:Print("~", data, "Precondition has_info (%s) is false", value)
				return false
				
			elseif (key == "dont_has_info") and has_alife_info(value) then
				self:Print("~", data, "Preconditions | dont_has_info (%s) is false", value)
				return false
				
			elseif (key == "condition") then
				if dl.precondition then
					self:Print("=", data, "Preconditions | testing precondition (%s)", str_func2(value))
					if (not self:Execute_Precondition(value) ) then
						self:Print("~", data, "Preconditions | precondition (%s) is false", str_func2(value))
						return false
					end
				elseif dl.conds then
					self:Print("=", data, "Preconditions | testing condition (%s)", str_func2(value))
					if (not self:Execute(value, dialog, node_last, node_now, who) ) then
						self:Print("~", data, "Preconditions | condition (%s) is false", str_func2(value))
						return false
					end
				end
			end
		end
	end
	
	-- If dialog is marked to run once, and it happened before -> disable it
	if dl.run_once and dialog and dialog_finished[dialog] then
		self:Print("~", data, "Preconditions | dialog was set to run once")
		return false
	end
	
	self:Print("+", data, "Preconditions are valid")
	return true
end

function UIDialog:Process_Actions(dialog, node_last, node_now, who)
	local data = str_data(dialog, node_last, node_now, who)
	--self:Print("=", data, "Actions")
	
	local dl = self:Get_Dialog(dialog, node_now)
	local actions = dl.actions
	if actions then
		for i,p in ipairs(actions) do
			local key = random_key_table(p)
			local value = p[key]

			if (key == "give_info") then
				self:Print("+", data, "Process_Actions | give_info (%s)", value)
				give_info(value)
				
			elseif (key == "disable_info") then
				self:Print("+", data, "Process_Actions | disable_info (%s)", value)
				disable_info(value)
				
			elseif (key == "action") then
				self:Print("+", data, "Process_Actions | action (%s)", str_func2(value))
				self:Execute(value, dialog, node_last, node_now, who)
			
			else
				printf("!UIDialog:Process_Actions | [%s] is not a valid action | %s", key, data)
			end
		end
	end
end

function UIDialog:Show_Question(text, index)
	self:Print("\\", "", "Show_Question | index: %s - text: %s", index, text)
	
	-- If elements aren't made yet, create them
	if (not self.ele_q[index]) then
		local xml = self.xml
		
		self.ele_q[index] = {}
		self.ele_q[index].base = xml:InitStatic("question_item", nil)
		self.ele_q[index].num = xml:InitTextWnd("question_item:num_text", self.ele_q[index].base)
		self.ele_q[index].context = xml:InitTextWnd("question_item:content_text", self.ele_q[index].base)
		self.ele_q[index].btn = xml:Init3tButton("question_item:btn", self.ele_q[index].base)
		self.ele_q[index].footer = xml:ReadAttribute("question_item", 0, "bottom_footer")
		
		self:Register(self.ele_q[index].btn, "question_" .. index)
		local _wrapper = function(handler) -- we need wrapper in order to pass ctrl to method
			self:Ask_Selected_Question(index)
		end
		self:AddCallback("question_" .. index, ui_events.BUTTON_CLICKED, _wrapper, self)
	end
	
	-- Assign values
	self.ele_q[index].context:SetText(text) -- could be a node or main dialog
	self.ele_q[index].context:AdjustHeightToText()
	
	self.ele_q[index].num:SetText(index and (index ..".") or "")
	
	utils_xml.sync_size(self.ele_q[index].context, self.ele_q[index].base, 0, tonumber(self.ele_q[index].footer) or 2)
	utils_xml.sync_size(self.ele_q[index].context, self.ele_q[index].btn)
	
	self.questions_list:AddWindow(self.ele_q[index].base, true)
	self.ele_q[index].base:SetAutoDelete(false)
end

function UIDialog:Show_Answer(caption, context, icon, element, sound)
	self:Print("\\", "", "Show_Answer | caption: %s - context: %s - icon: %s - element: %s", caption, context, icon, element)

	local xml = self.xml
	if (not xml:NodeExist(element, 0)) then
		printf("!UIDialog:Show_Answer | Answer element [%s] doesn't exist", element)
		return
	end
	
	local box = xml:InitStatic(element, nil)
	if caption and xml:NodeExist(element .. ":name_caption", 0) then
		local ele_caption = xml:InitTextWnd(element .. ":name_caption", box)
		ele_caption:SetText(caption)
		ele_caption:AdjustHeightToText()
	end

	if context and xml:NodeExist(element .. ":content_text", 0) then
		local ele_text = xml:InitTextWnd(element .. ":content_text", box)
		ele_text:SetText(context)
		ele_text:AdjustHeightToText()
		
		if icon and type(icon) == "string" and xml:NodeExist(element .. ":msg_icon", 0) then
			local ele_icon = xml:InitStatic(element .. ":msg_icon", box)
			ele_icon:InitTexture(icon)
		end
		
		local footer = xml:ReadAttribute(element, 0, "bottom_footer")
		box:SetWndSize(vector2():set( box:GetWidth(), ele_text:GetHeight() + ele_text:GetWndPos().y + (tonumber(footer) or 10) ))
	
		self.answers_list:AddWindow(box, true)
		box:SetAutoDelete(false)
	end

	self.answers_list:ScrollToEnd()
	
	-- play sound
	if sound then
		xr_sound.set_sound_play(AC_ID, sound)
	end
end

function UIDialog:Show_Relocated_Items(type, item_list)
	local xml = self.xml
	
	local c
	for i,b in ipairs(self.item_boxes) do
		if (b.active == false) then
			c = i
			break
		end
	end
	if (not c) then
		c = #self.item_boxes + 1
		self.item_boxes[c] = {}
		self.item_boxes[c].box = xml:InitStatic("relocated_item", nil)
		self.item_boxes[c].caption = xml:InitTextWnd("relocated_item:name_caption", self.item_boxes[c].box)
		self.item_boxes[c].icon = xml:InitStatic("relocated_item:msg_icon", self.item_boxes[c].box)
		self.item_boxes[c].CC = utils_ui.UICellContainer("relocated_items_"..c, self, nil, "relocated_item:container", self.item_boxes[c].box)
		self.item_boxes[c].CC.showcase              = true
		self.item_boxes[c].CC.showcase_counter      = true
		self.item_boxes[c].CC.can_select	        = false
		self.item_boxes[c].CC.disable_drag          = true
		--self.item_boxes[c].CC.disable_stack       = true
		self.item_boxes[c].CC.disable_scroll        = true
		
		local grid_size = tonumber(xml:ReadAttribute("relocated_item:container", 0, "grid_size")) or 35
		local grid_line = tonumber(xml:ReadAttribute("relocated_item:container", 0, "grid_line")) or 2
		self.item_boxes[c].CC:SetGridSpecs(grid_size, grid_line)
	end
	
	self.item_boxes[c].active = true
	
	local cap = (type == "in") and "general_in_item" or "general_out_item"
	self.item_boxes[c].caption:SetText( game.translate_string(cap) )
	
	local ico = (type == "in") and "ui_inGame2_Predmet_poluchen" or "ui_inGame2_Predmet_otdan"
	self.item_boxes[c].icon:InitTexture(ico)
	
	self.item_boxes[c].CC:Reinit(item_list)
	self.item_boxes[c].CC:AdjustHeightToCell()
	
	local footer = xml:ReadAttribute("relocated_item", 0, "bottom_footer")
	local w = self.item_boxes[c].box:GetWidth()
	local h = self.item_boxes[c].CC.prof:GetWndPos().y + self.item_boxes[c].CC.prof:GetHeight() + (tonumber(footer) or 10)
	self.item_boxes[c].box:SetWndSize(vector2():set( w, h ))
	
	self.answers_list:AddWindow(self.item_boxes[c].box, true)
	self.item_boxes[c].box:SetAutoDelete(false)
	
	self.answers_list:ScrollToEnd()
end

-- Utilities
function UIDialog:Get_Dialog_Cache(dialog)
	if (not dialog) then
		printe("!UIDialog:Get_Dialog_Cache | no dialog passed")
		callstack()
		return
	end

	if (not self.dialogs[dialog]) then
		self.dialogs[dialog] = dup_table(dialog_list[dialog])
	end
	return self.dialogs[dialog]
end

function UIDialog:Get_Dialog(dialog, node)
	dialog = dialog or self.D
	
	-- Caching dialog
	local dl = self:Get_Dialog_Cache(dialog)
	if (not dl) then
		printe("!ERROR UIDialog:Get_Dialog | dialog [%s] doesn't exist", dialog)
	end
	
	-- Processing dialog functor
	if dl.functor and (not dl.phrases) then
	
		-- this will be attached to self.dialogs[dialog] ?
		if (not dialog_script) then
			dialog_script = DialogScripted()
		end
		dl.phrases = dialog_script:Process(dialog, dl.functor)
	end

	-- When node is passed, return related phrase
	if node then
		if dl.phrases then
			local phrase = dl.phrases[node]
			if phrase then
				return phrase
			else
				printe("!ERROR Get_Dialog | dialog [%s] [%s] doesn't exist", dialog, node)
			end
		end
	end
	
	-- otherwise return the dialog tree
	return dl
end

function UIDialog:Get_Dialog_Property(dialog, prop)
	local dl = self:Get_Dialog(dialog)
	local prop = dl and dl[prop]
	if prop then
		return prop
	end
end

function UIDialog:Get_Text(dialog, node_last, node_now, who)
	node_now = node_now or "0"
	
	local data = str_data(dialog, node_last, node_now, who)
	self:Print("*", data, "Get_Text")
	
	if (not dialog) then
		self:Print("!", "", "Get_Text | no dialog passed")
		return false
	end
	
	local txt
	local dlp = self:Get_Dialog(dialog, node_now)
	if dlp.script_text then
		txt = self:Execute(dlp.script_text, dialog, node_last, node_now, who)
	elseif dlp.text then
		txt = dlp.text
	end
	
	if txt and (txt ~= "") then
		return txt
	end
	return false
end

function UIDialog:Get_NPC()
	local id = self.ID
	if id then
		if self.offline then
			return alife_object(id)
		end
		return db.storage[id] and db.storage[id].object or level.object_by_id(id)
	end
	printe("!UIDialog:Get_NPC | missing NPC ID!")
end

function UIDialog:Get_NPC_Name()
	local npc = self:Get_NPC()
	if (not npc) then
		return ""
	end
	
	if self.name then
		return game.translate_string(self.name)
	elseif self.is_npc then
		return game.translate_string(npc:character_name())
	end
	return game.translate_string("st_dyn_news_unknown_contact")
end

function UIDialog:Get_NPC_Icon()
	local npc = self:Get_NPC()
	if (not npc) then
		return "ui_icon_news_trx_common"
	end
	
	if self.icon then
		return self.icon
	elseif self.is_npc then
		return npc:character_icon()
	end
	return "ui_icon_news_trx_common"
end


function UIDialog:Execute(f, dialog, node_last, node_now, who)
	local data = str_data(dialog, node_last, node_now, who)
	local file, func, params = extract_func(f)
	
	if (not func) then		
		printe("!ERROR UIDialog:Execute | no passed func name")
		callstack()
		return
	end
	
	local speaker, listener
	if who then
		speaker = db.actor 
		listener = self:Get_NPC()
	else
		speaker = self:Get_NPC()
		listener = db.actor 
	end
	
	--self:Print("@", data, "Execute | %s", str_func(file, func, params))
	if file and _G[file] and _G[file][func] then
		return _G[file][func](speaker, listener, dialog, node_last, node_now, unpack(params or {}))
	elseif _G[func] then
		return _G[func](speaker, listener, dialog, node_last, node_now, unpack(params or {}))
	end
	
	printe("!Warning UIDialog:Execute | file or func not found | file: %s , func: %s", file, func)
end

function UIDialog:Execute_Precondition(f)
	local file, func, params = extract_func(f)

	--self:Print("@", "", "Execute_Precondition | %s", str_func(file, func, params))
	if file and _G[file] and _G[file][func] then
		return _G[file][func](db.actor, self:Get_NPC(), unpack(params or {}))
	elseif _G[func] then
		return _G[func](db.actor, self:Get_NPC(), unpack(params or {}))
	end
	
	printe("!Warning UIDialog:Execute_Precondition | file or func not found | file: %s , func: %s", file, func)
end

-- Temp hiding
function UIDialog:Hold_Conversation(what, state)
	if (what == "UIInventory") then
		if state and self:IsShown() then
			self.stand_by = true
			self:Show(false)
			
		elseif (not state) and (not self:IsShown()) and self.stand_by then
			self.stand_by = false
			self:Show(true)
		end
	end
end

-- End
function UIDialog:OnKeyboard(dik, keyboard_action)
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
			if (dik == DIK_keys.DIK_ESCAPE) or (bind == key_bindings.kUSE) then
				self:Close()
			else
				for i=1,9 do
					if dik == DIK_keys["DIK_" .. i] then
						self:Ask_Selected_Question(i)
					end
				end
			end
		end
	end
	return res
end

function UIDialog:Close()
	self:Print("*", "", "Close")
	
	self:HideDialog()
	self:Show(false)
	Unregister_UI("Dialog")
	
	-- Needed for now to simulate engine functionality in calling this
	actor_menu.actor_menu_mode(11)
	pda.actor_menu_mode(11)
end

function UIDialog:Print(mark, data, fmt, ...)
	if enable_debug then
		printf((mark or "") .. "UIDialog %s | " .. fmt, data, ...)
	end
end



----------------------------------------------------------------------
-- Scripted Dialog
----------------------------------------------------------------------
class "DialogScripted"

function DialogScripted:__init()
	self:Print("-", "__init")

	self.F = {}
	self.dialog = false
	self.last_id = false
end

function DialogScripted:Process(name, f)
-- Call other scripts to begin dialog attaching

	empty_table(self.F)
	self.dialog = name
	
	local file, func, params = extract_func(f)
	
	if (not func) then		
		printe("!ERROR UIDialog:Execute | no passed func name")
		callstack()
		return
	end
	
	self:Print("@", "Process | %s", str_func(file, func, params))
	if file and _G[file] and _G[file][func] then
		_G[file][func](self, unpack(params or {}))
	elseif func and _G[func] then
		_G[func](self, unpack(params or {}))
	else
		printe("!Warning UIDialog:Execute | file or func not found | file: %s - func: %s", file, func)
	end
	
	self:Clean()
	return dup_table(self.F)
end

function DialogScripted:AddPhrase(text, node_now, node_last, goodwill)
	self:Print("=", "AddPhrase( text: %s - node_now: %s - node_last: %s - goodwill: %s )", text, node_now, node_last, goodwill)
	--node_now = tonumber(node_now)
	--node_last = tonumber(node_last)
	
	-- handling last node
	if node_last and (node_last ~= "") then
		if (not self.F[node_last]) then
			self.F[node_last] = {}
		end
		if (not self.F[node_last].next) then
			self.F[node_last].next = {}
		end
		local cnt = #self.F[node_last].next + 1
		self.F[node_last].next[cnt] = node_now
	end
	
	-- handling current node
	if (not self.F[node_now]) then
		self.F[node_now] = {}
	end
	
	if text and (text ~= "") then
		self.F[node_now].text = text
	end
	
	self.last_id = node_now
	
	return self
end

function DialogScripted:GetPhraseScript()
	self:Print("=", "GetPhraseScript")
	return self
end

function DialogScripted:AddPrecondition(value)
	self:Print("=", "AddPrecondition: %s", value)
	
	local node = self.last_id
	
	if (not self.F[node].conds) then
		self.F[node].conds = {}
	end
	
	if type(value) == "table" then
		for i,c in ipairs(value) do
			local t = parse_custom_func(c, true)
			local cnt = #self.F[node].conds + 1
			self.F[node].conds[cnt] = { ["condition"] = t }
		end
	else
		local t = parse_custom_func(value, true)
		local cnt = #self.F[node].conds + 1
		self.F[node].conds[cnt] = { ["condition"] = t }
	end
end

function DialogScripted:AddAction(value)
	self:Print("=", "AddPrecondition: %s", value)
	local node = self.last_id
	
	if (not self.F[node].actions) then
		self.F[node].actions = {}
	end
	
	if type(value) == "table" then
		for i,c in ipairs(value) do
			local t = parse_custom_func(c, true)
			local cnt = #self.F[node].actions + 1
			self.F[node].actions[cnt] = { ["action"] = t }
		end
	else
		local t = parse_custom_func(value, true)
		local cnt = #self.F[node].actions + 1
		self.F[node].actions[cnt] = { ["action"] = t }
	end
end

function DialogScripted:SetScriptText(text)
	self:Print("=", "SetScriptText: %s", text)
	local node = self.last_id
	
	self.F[node].text = nil
	self.F[node].script_text = text and (text ~= "") and parse_custom_func(text, true)
end

function DialogScripted:Clean()
	self:Print("=", "Clean")
	for node,v in pairs(self.F) do
		if v.next and is_empty(v.next) then
			self.F[node].next = nil
		end
	end
end

function DialogScripted:Print(mark, fmt, ...)
	if enable_debug then
		--printf((mark or "") .. "DialogScripted | " .. fmt, ...)
	end
end


----------------------------------------------------------------------
-- Utilities
----------------------------------------------------------------------
function overrides_1()

	game_object.stop_talk = function(self)
		if (GUI and GUI:IsShown()) and (self:id() == AC_ID or self:id() == GUI.ID) then
			GUI:Close()
		end
	end
	
	game_object.is_talking = function(self)
		return (GUI and GUI:IsShown()) and (self:id() == AC_ID or self:id() == GUI.ID)
	end
	
	game_object.set_start_dialog = function(self, dialog)
		engine_start_dialog[self:id()] = dialog
	end
	
	game_object.restore_default_start_dialog = function(self)
		engine_start_dialog[self:id()] = nil
	end

	game_object.give_talk_message2 = function(self, caption, text, icon, element)
		if (not show_info(caption, text, icon, element)) then
			self:give_game_news(caption, text, icon, 0, 5000)
		end
	end

		--self.npc:allow_break_talk_dialog(self.allow_break)
		--db.actor:run_talk_dialog(self.npc, not(self.allow_break))
		--self.npc:set_tip_text("character_use")

end
if enable_feature then overrides_1() end

function overrides_2()

-------------------------------------------------
	--GhenTuong: It crashes.
	--news_manager.relocate_item = function(actor, type, item, amount)
	--	show_relocated_item(type, item, amount)
	--end
	
	_G.get_speaker = function(safe, all)
		return GUI and GUI:IsShown() and GUI:Get_NPC()
	end
-------------------------------------------------
	--
	dialog_manager.precondition_job_dialogs_do_not_know = function(npc, actor, dialog_name, parent_id, id)
		return dialog_manager.precondition_no_more(npc, "job", id, dialog_manager.priority_table.job)
	end
	
	dialog_manager.precondition_anomalies_dialogs_do_not_know = function(npc, actor, dialog_name, parent_id, id)
		return dialog_manager.precondition_no_more(npc, "anomalies", id, dialog_manager.priority_table.anomalies)
	end
	
	dialog_manager.precondition_information_dialogs_do_not_know = function(npc, actor, dialog_name, parent_id, id)
		return dialog_manager.precondition_no_more(npc, "information", id, dialog_manager.priority_table.information)
	end
	
	dialog_manager.precondition_tips_dialogs_do_not_know = function(npc, actor, dialog_name, parent_id, id)
		return dialog_manager.precondition_no_more(npc, "tips", id, dialog_manager.priority_table.tips)
	end
	
	dialog_manager.precondition_no_more = function(npc, str, phrase_id, PRT_subtable)
		local id = npc:id()
		if (dialog_manager.priority_table[str] == nil or dialog_manager.priority_table[str][id] == nil) then
			return true
		end
	
		local pr, id = dialog_manager.get_highest_priority_phrase(dialog_manager.phrase_table[str], dialog_manager.priority_table[str], npc, phrase_id)
		if(pr<0) or (id==0) then
			printf("there is no avaliable "..str.." dialogs")
			return true
		end
	
		if (not PRT_subtable[id]) then
			return true
		end
		if (PRT_subtable[id][phrase_id] == nil or PRT_subtable[id][phrase_id] == -1) then
			return true
		end
	
		return false
	end
	--
end

function extract_func(f)
	local params
	if #f > 2 then
		params = {}
		for i=3,#f do
			params[#params+1] = f[i]
		end
	end
	return f[1], f[2], params
end

-- format text
function str_nodes(t)
	local str = "["
	for i,node in ipairs(t) do
		str = str .. node .. ((i < #t) and "|" or "")
	end
	str = str .. "]"
	return str
end

function str_data(dialog, node_last, node_now, who)
	return strformat("(%s) [%s] -> [%s] - Who: %s", dialog or "-", node_last or "-", node_now or "-", who and "Actor" or "NPC")
end

function str_func(file, func, params)
	if file then
		return strformat("%s.%s(%s)", file,func, str_params(params))
	end
	return strformat("%s(%s)", func, str_params(params))
end

function str_func2(f)
	local file, func, params = extract_func(f)
	if file then
		return strformat("%s.%s(%s)", file,func, str_params(params))
	end
	return strformat("%s(%s)", func, str_params(params))
end

function str_params(params)
	if (not params) then
		return ""
	end
	
	local str = ""
	for i,p in ipairs(params) do
		str = str .. tostring(p) .. ","
	end
	return str
end


-- initiate dialogs
function prepare_dialog_table()

	empty_table(dialog_list)
	
	-- Collect dialog files
	local dir = "gameplay"
	local files = parse_list(ini_sys,"dialogs","files",true)
	
	-- Parse files
	for file,_ in pairs(files) do
		file = file..".xml"
		
		local xml = CScriptXmlInit()
		xml:ParseDirFile (dir,file)
		
		for i=0,xml:GetNodesNum("game_dialogs", 0, "dialog")-1 do
			local dialog = xml:ReadAttribute("dialog", i, "id")
			if dialog and dialog ~= "" then
				dialog_list[dialog] = parse_dialog(xml, dialog)
			end
		end
	end
	
	-- Validate
	for dialog, v in pairs(dialog_list) do
		local ps = v.phrases
		if ps then
			for id,p in pairs(ps) do
				if p.next then
					for i,n in ipairs(p.next) do
						if (not ps[n]) then
							printe("!ERROR dialog: %s - phrase id [%s] has next [%s] which leads to nothing!", dialog, id, n)
						end
					end
				end
			end
		end
	end
end

function parse_dialog(xml, dialog)

	xml:NavigateToRoot()
	xml:NavigateToNode_ByAttribute("dialog", "id", dialog)
	
	local t = {}
	local c = 0
	
-------------------- preconditions
	-- precondition
	for i=0,xml:GetNodesNum("dialog", 0, "precondition")-1 do
		if (not t.precondition) then t.precondition = {} end
		c = c + 1
		
		local value = xml:ReadValue("precondition", i)
		if value and value ~= "" then
			t.precondition[c] = { ["condition"] = parse_custom_func(value, true) }
		end
	end
	
	-- has_info
	for i=0,xml:GetNodesNum("dialog", 0, "has_info")-1 do
		if (not t.precondition) then t.precondition = {} end
		c = c + 1
		
		local value = xml:ReadValue("has_info", i)
		if value and value ~= "" then
			t.precondition[c] = { ["has_info"] = value }
		end
	end
	
	-- dont_has_info
	for i=0,xml:GetNodesNum("dialog", 0, "dont_has_info")-1 do
		if (not t.precondition) then t.precondition = {} end
		c = c + 1
		
		local value = xml:ReadValue("dont_has_info", i)
		if value and value ~= "" then
			t.precondition[c] = { ["dont_has_info"] = value }
		end
	end
	
-------------------- technical
	if xml:NodeExist("init_func", 0) then
		local value = xml:ReadValue("init_func", 0)
		if value and value ~= "" then
			t.functor = parse_custom_func(value, true)
		end
	end
	
	if xml:NodeExist("run_once", 0) then
		local value = xml:ReadValue("run_once", 0)
		if value and value ~= "" then
			t.run_once = value
		else
			t.run_once = true
		end
	end
	
-------------------- phrase_list
	if xml:NodeExist("phrase_list", 0) then
		xml:NavigateToNode("phrase_list",0)
		t.phrases = {}
			
		for i=0,xml:GetNodesNum("phrase_list", 0, "phrase")-1 do
			local id = xml:ReadAttribute("phrase", i, "id")
			t.phrases[id] = {}
			
			-- Text
			local text = xml:ReadValue("phrase:text", i)
			if text and (text ~= "") then
				t.phrases[id].text = text
			end
			
			-- Script text
			local script_text = xml:ReadValue("phrase:script_text", i)
			if script_text and (script_text ~= "") then
				t.phrases[id].script_text = parse_custom_func(script_text, true)
			end
			
			--------------------------
			local cnt_next          = xml:GetNodesNum("phrase", i,"next")-1
			local cnt_precondition  = xml:GetNodesNum("phrase", i,"precondition")-1
			local cnt_has_info      = xml:GetNodesNum("phrase", i,"has_info")-1
			local cnt_dont_has_info = xml:GetNodesNum("phrase", i,"dont_has_info")-1
			local cnt_action        = xml:GetNodesNum("phrase", i,"action")-1
			local cnt_give_info     = xml:GetNodesNum("phrase", i,"give_info")-1
			local cnt_disable_info  = xml:GetNodesNum("phrase", i,"disable_info")-1
			xml:NavigateToNode("phrase",i)
			
			c = 0
			for j=0,cnt_has_info do
				if (not t.phrases[id].conds) then t.phrases[id].conds = {} end
	
				local value = xml:ReadValue("has_info", j)
				if value and (value ~= "") then
					c = c + 1
					t.phrases[id].conds[c] = { ["has_info"] = value }
				end
			end
			for j=0,cnt_dont_has_info do
				if (not t.phrases[id].conds) then t.phrases[id].conds = {} end
	
				local value = xml:ReadValue("dont_has_info", j)
				if value and (value ~= "") then
					c = c + 1
					t.phrases[id].conds[c] = { ["dont_has_info"] = value }
				end
			end
			for j=0,cnt_precondition do
				if (not t.phrases[id].conds) then t.phrases[id].conds = {} end
	
				local value = xml:ReadValue("precondition", j)
				if value and (value ~= "") then
					c = c + 1
					t.phrases[id].conds[c] = { ["condition"] = parse_custom_func(value, true) }
				end
			end
			
			c = 0
			for j=0,cnt_next do
				if (not t.phrases[id].next) then t.phrases[id].next = {} end
	
				local nex = xml:ReadValue("next", j)
				if nex and nex ~= "" then
					c = c + 1
					t.phrases[id].next[c] = nex
				end
			end
			
			c = 0
			for j=0,cnt_give_info do
				if (not t.phrases[id].actions) then t.phrases[id].actions = {} end
	
				local value = xml:ReadValue("give_info", j)
				if value and (value ~= "") then
					c = c + 1
					t.phrases[id].actions[c] = { ["give_info"] = value }
				end
			end
			for j=0,cnt_disable_info do
				if (not t.phrases[id].actions) then t.phrases[id].actions = {} end
	
				local value = xml:ReadValue("disable_info", j)
				if value and (value ~= "") then
					c = c + 1
					t.phrases[id].actions[c] = { ["disable_info"] = value }
				end
			end
			for j=0,cnt_action do
				if (not t.phrases[id].actions) then t.phrases[id].actions = {} end
	
				local value = xml:ReadValue("action", j)
				if value and (value ~= "") then
					c = c + 1
					t.phrases[id].actions[c] = { ["action"] = parse_custom_func(value, true) }
				end
			end
			
			xml:NavigateToRoot()
			xml:NavigateToNode_ByAttribute("dialog", "id", dialog)
			xml:NavigateToNode("phrase_list",0)
			--------------------------
		end
	end
	
-------------------- finale
	xml:NavigateToRoot()
	return t
end

-- initiate characters
function prepare_character_table()
	local string_find = string.find
	local string_sub = string.sub
	local string_gsub = string.gsub
	empty_table(character_list)
	
	-- Collect character_desc files
	local dir = "gameplay"
	local files = parse_list(ini_sys,"profiles","specific_characters_files",true)
	
	-- Parse files
	for file,_ in pairs(files) do
		file = file..".xml"
		
		local xml = CScriptXmlInit()
		xml:ParseDirFile (dir,file)
		
		for i=0,xml:GetNodesNum("xml", 0, "specific_character")-1 do
			local character = xml:ReadAttribute("specific_character", i, "id")
			if character and character ~= "" then
				local character_full = character
			
				-- remove copies of sim_default profiles
				local _,__,num = string_find(character, "_default_(%d+)")
				if num then
					local a = "_default_" .. num
					local as = string_sub(character, -1 * #a)
					if (a == as) then
						character = string_gsub(character, as, "")
					end
				end
				
				if (character_list[character] == nil) then
					character_list[character] = parse_character(xml, character_full)
				end
			end
		end
	end
end

function parse_character(xml, character)
	xml:NavigateToRoot()
	xml:NavigateToNode_ByAttribute("specific_character", "id", character)
	
	local t = {}
	local c = 0
	
	-- start dialogs
	for i=0,xml:GetNodesNum("specific_character", 0, "start_dialog")-1 do
		if (not t.start_dialog) then t.start_dialog = {} end
		
		local value = xml:ReadValue("start_dialog", i)
		if value and value ~= "" then
			c = c + 1
			t.start_dialog[c] = {value}
		end
	end
	
	-- actor dialogs
	c = 0
	for i=0,xml:GetNodesNum("specific_character", 0, "actor_dialog")-1 do
		if (not t.actor_dialog) then t.actor_dialog = {} end

		local value = xml:ReadValue("actor_dialog", i)
		if value and value ~= "" then
			c = c + 1
			t.actor_dialog[c] = {value}
		end
	end
	
	xml:NavigateToRoot()
	
	if is_not_empty(t) then
		return t
	else
		return false
	end
end

--[[
	How XML dialog is converted to table inside this script:
	
	XML:
		<dialog id="sidorovich_questlines_about_dialog">
			<precondition>dialogs.actor_true_stalker</precondition>
			<dont_has_info>story_mode_disabled</dont_has_info>
			<has_info>faction_limited_playthrough</has_info>
			<phrase_list>
				<phrase id="0">  <!-- Actor -->
					<text>dialog_text_0</text>
					<next>1</next>
					<next>2</next>
					<next>3</next>
				</phrase>
				<phrase id="1">  <!-- NPC -->
					<text>dialog_text_1</text>
					<give_info>questlines_about_info</give_info>
					<next>4</next>
				</phrase>
				<phrase id="2">  <!-- NPC -->
					<text>dialog_text_2</text>
					<disable_info>start_game_esc_m_trader</disable_info>
					<action>xr_effects.decrease_sl_tasks_count(4)</action>
					<action>xr_effects.decrease_tasks(true,0,false)</action>
					<next>4</next>
				</phrase>
				<phrase id="3">  <!-- NPC -->
					<script_text>dialogs.text_3_function</script_text>
					<precondition>dialogs.level_name(zaton)</precondition>
					<has_info>zaton_not_visited</has_info>
				</phrase>
				<phrase id="4">  <!-- Actor -->
					<script_text>dialogs.goodbye_text</script_text>
				</phrase>
			</phrase_list>
		</dialog>
	
	LUA:	
		dialog_list["sidorovich_questlines_about_dialog"] = {
			precondition = {
				[1] = { ["condition"] = {"dialogs","actor_true_stalker"} },
				[2] = { ["dont_has_info"] = "story_mode_disabled" },
				[3] = { ["has_info"] = "faction_limited_playthrough" },
			},
			phrases = {
				[0] = {
					text = "dialog_text_0",
					next = {1,2,3},
				},
				[1] = {
					text = "dialog_text_1",
					actions = {
						[1] = { ["give_info"] = "questlines_about_info" }
					},
					next = {4},
				},
				[2] = {
					text = "dialog_text_2",
					actions = {
						[1] = { ["disable_info"] = "start_game_esc_m_trader" },
						[2] = { ["action"] = {"xr_effects","decrease_sl_tasks_count",4} }, 
						[3] = { ["action"] = {"xr_effects","decrease_tasks",true,0,false} },
					},
					next = {4},
				},
				[3] = {
					script_text = {"dialogs","text_3_function"},
					conds = {
						[1] = { ["condition"] = {"dialogs","level_name","zaton"} },
						[2] = { ["has_info"] = "zaton_not_visited" },
					},
					next = {4},
				},
				[4] = {
					script_text = {"dialogs","goodbye_text"},
				},
			},
		}
--]]
